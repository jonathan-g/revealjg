% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/revealjs_presentation.R
\name{postprocessor_function}
\alias{postprocessor_function}
\title{Postprocess a reveal.js HTML file}
\usage{
postprocessor_function(metadata, input_file, output_file, clean, verbose)
}
\arguments{
\item{metadata}{YAML metadata passed by \code{rmarkdown::render}}

\item{input_file}{The RMarkdown source file}

\item{output_file}{The HTML file produced by Pandoc}

\item{clean}{A logical value indicating whether to delete the intermediate
files after rendering.}

\item{verbose}{Issue verbose progress reports while rendering.}
}
\value{
A character string with the name of the output file.\preformatted{* {+4} This has index 4, so it appears out of order
* {+1:blue} This fragment uses the `highlight-blue` class.
* {+3:red} This fragment has index 6 and highlights in red.
* {+2:grow} This fragment grows when it's activated
* {.fragment .grow data-fragment-index="1"} This fragment grows at the same time the first one appears.
}
}
\description{
Postprocesses a reveal.js HTML file to modify list items with user-supplied
classes.
}
\details{
This function is predominantly intended for giving finer-scale control to
fragments in lists. From the RMarkdown perspective, a list item can be
modified by adding metadata in curly braces immediately after the \code{*}.

The contents of the braces are parsed for classes and fragment indices.
Examples include:\preformatted{* {.fragment} This is a simple fragment.
* {+} This is another simple fragment.
}

You can also play with fragment indices to control the order in which
fragments appear, but if you do then you need to set the indices for every
fragment in the list. You can also add classes to control what the fragments
do when they're activated.
}
